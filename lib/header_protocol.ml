(* This file is automatically generated by a target in the build system.
   Do not modify it by hand.  *)

open Core.Std
let padding = ' '
let _ = padding


module R = struct
  type 'message t =
   | Need_more_data
   | Ok of 'message * int
   | Junk of exn * (int, exn) Result.t
   with sexp_of
end

module New_single = struct
  

  type t_unpacked = {
    message_length : int;
    message_type : char;
    id : Probe_id.t;
    spec : Probe_type.t;
    name : string;
  } with sexp
  type (-'rw) t = ('rw, Iobuf.no_seek) Iobuf.t constraint 'rw = [> read ]

  let message_length = 69 - 0
  let message_type = 'N'

  let buffer_length  = message_length + 0
  let write ~id ~spec ~name buf =
    let pos = 0 in
    assert(Iobuf.length buf >= message_length + 0);
    Core.Iobuf.Unsafe.Poke.char buf ~pos:(pos  + 1) (message_type);
    Core.Iobuf.Unsafe.Poke.uint16_le buf ~pos:(pos  + 2) (Probe_id.to_int_exn id);
    Core.Iobuf.Unsafe.Poke.char buf ~pos:(pos  + 4) ((Probe_type.to_char spec));
    Core.Iobuf.Unsafe.Poke.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 5) name;
    let total_bytes_packed = 69 in
    Core.Iobuf.Unsafe.Poke.uint8 buf ~pos:(pos  + 0) (total_bytes_packed - 0);
    total_bytes_packed
  ;;

  let create ~id ~spec ~name =
    let iobuf = Iobuf.create ~len:(message_length + 0) in
    let size = write ~id ~spec ~name iobuf in
    assert (Iobuf.length iobuf = size);
    iobuf
  let get_message_length buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos  + 0)
  ;;
  let get_message_type buf =
    let pos = 0 in
    (Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos  + 1))
  ;;
  let get_id buf =
    let pos = 0 in
    Probe_id.of_int_exn (Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 2))
  ;;
  let get_spec buf =
    let pos = 0 in
    Probe_type.of_char ((Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos  + 4)))
  ;;
  let get_name buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 5)
  ;;
  let set_id buf field =
    let pos = 0 in
    Core.Iobuf.Poke.uint16_le buf ~pos:(pos  + 2) (Probe_id.to_int_exn field);
  ;;
  let set_spec buf field =
    let pos = 0 in
    Core.Iobuf.Poke.char buf ~pos:(pos  + 4) ((Probe_type.to_char field));
  ;;
  let set_name buf field =
    let pos = 0 in
    Core.Iobuf.Poke.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 5) field;
  ;;
  let to_sub_iobuf t = 
    Iobuf.sub t ~len:(get_message_length t + 0)
  ;;
  let to_unpacked buf =
    assert(buffer_length <= Iobuf.length buf);
    {
      message_length = get_message_length buf;
      message_type = get_message_type buf;
      id = get_id buf;
      spec = get_spec buf;
      name = get_name buf;
    }
  let of_unpacked iobuf u =
    let res = write iobuf
      ~id:u.id
      ~spec:u.spec
      ~name:u.name
    in
    res
  let sexp_of_t _ t = sexp_of_t_unpacked (to_unpacked t)

  let t_of_sexp _ sexp =
    let unpacked = t_unpacked_of_sexp sexp in
    let t = Iobuf.create ~len:(message_length + 0) in
    ignore (of_unpacked t unpacked : int);
    Iobuf.of_string (Iobuf.to_string t)
  ;;
  
end

module New_group = struct
  

  type t_unpacked = {
    message_length : int;
    message_type : char;
    id : Probe_id.t;
    spec : Probe_type.t;
    name : string;
  } with sexp
  type (-'rw) t = ('rw, Iobuf.no_seek) Iobuf.t constraint 'rw = [> read ]

  let message_length = 69 - 0
  let message_type = 'P'

  let buffer_length  = message_length + 0
  let write ~id ~spec ~name buf =
    let pos = 0 in
    assert(Iobuf.length buf >= message_length + 0);
    Core.Iobuf.Unsafe.Poke.char buf ~pos:(pos  + 1) (message_type);
    Core.Iobuf.Unsafe.Poke.uint16_le buf ~pos:(pos  + 2) (Probe_id.to_int_exn id);
    Core.Iobuf.Unsafe.Poke.char buf ~pos:(pos  + 4) ((Probe_type.to_char spec));
    Core.Iobuf.Unsafe.Poke.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 5) name;
    let total_bytes_packed = 69 in
    Core.Iobuf.Unsafe.Poke.uint8 buf ~pos:(pos  + 0) (total_bytes_packed - 0);
    total_bytes_packed
  ;;

  let create ~id ~spec ~name =
    let iobuf = Iobuf.create ~len:(message_length + 0) in
    let size = write ~id ~spec ~name iobuf in
    assert (Iobuf.length iobuf = size);
    iobuf
  let get_message_length buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos  + 0)
  ;;
  let get_message_type buf =
    let pos = 0 in
    (Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos  + 1))
  ;;
  let get_id buf =
    let pos = 0 in
    Probe_id.of_int_exn (Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 2))
  ;;
  let get_spec buf =
    let pos = 0 in
    Probe_type.of_char ((Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos  + 4)))
  ;;
  let get_name buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 5)
  ;;
  let set_id buf field =
    let pos = 0 in
    Core.Iobuf.Poke.uint16_le buf ~pos:(pos  + 2) (Probe_id.to_int_exn field);
  ;;
  let set_spec buf field =
    let pos = 0 in
    Core.Iobuf.Poke.char buf ~pos:(pos  + 4) ((Probe_type.to_char field));
  ;;
  let set_name buf field =
    let pos = 0 in
    Core.Iobuf.Poke.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 5) field;
  ;;
  let to_sub_iobuf t = 
    Iobuf.sub t ~len:(get_message_length t + 0)
  ;;
  let to_unpacked buf =
    assert(buffer_length <= Iobuf.length buf);
    {
      message_length = get_message_length buf;
      message_type = get_message_type buf;
      id = get_id buf;
      spec = get_spec buf;
      name = get_name buf;
    }
  let of_unpacked iobuf u =
    let res = write iobuf
      ~id:u.id
      ~spec:u.spec
      ~name:u.name
    in
    res
  let sexp_of_t _ t = sexp_of_t_unpacked (to_unpacked t)

  let t_of_sexp _ sexp =
    let unpacked = t_unpacked_of_sexp sexp in
    let t = Iobuf.create ~len:(message_length + 0) in
    ignore (of_unpacked t unpacked : int);
    Iobuf.of_string (Iobuf.to_string t)
  ;;
  
end

module New_group_point = struct
  

  type t_unpacked = {
    message_length : int;
    message_type : char;
    group_id : Probe_id.t;
    id : Probe_id.t;
    name : string;
    sources_id : Probe_id.t array;
  } with sexp
  type (-'rw) t = ('rw, Iobuf.no_seek) Iobuf.t constraint 'rw = [> read ]

  let message_length = 72 - 0
  let message_type = 'O'

  let buffer_length ~sources_count = message_length + 0 + 2 * sources_count
  let write ~group_id ~id ~name ~sources_count buf =
    let pos = 0 in
    assert(Iobuf.length buf >= message_length + 0 + 2 * sources_count);
    Core.Iobuf.Unsafe.Poke.char buf ~pos:(pos  + 1) (message_type);
    Core.Iobuf.Unsafe.Poke.uint16_le buf ~pos:(pos  + 2) (Probe_id.to_int_exn group_id);
    Core.Iobuf.Unsafe.Poke.uint16_le buf ~pos:(pos  + 4) (Probe_id.to_int_exn id);
    Core.Iobuf.Unsafe.Poke.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 6) name;
    Core.Iobuf.Unsafe.Poke.uint16_le buf ~pos:(pos  + 70) sources_count;
    let total_bytes_packed = 72 + sources_count * 2 in
    Core.Iobuf.Unsafe.Poke.uint8 buf ~pos:(pos  + 0) (total_bytes_packed - 0);
    total_bytes_packed
  ;;

  let create ~group_id ~id ~name ~sources_count =
    let iobuf = Iobuf.create ~len:(message_length + 0 + 2 * sources_count) in
    let size = write ~group_id ~id ~name ~sources_count iobuf in
    assert (Iobuf.length iobuf = size);
    iobuf
  let get_message_length buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos  + 0)
  ;;
  let get_message_type buf =
    let pos = 0 in
    (Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos  + 1))
  ;;
  let get_group_id buf =
    let pos = 0 in
    Probe_id.of_int_exn (Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 2))
  ;;
  let get_id buf =
    let pos = 0 in
    Probe_id.of_int_exn (Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 4))
  ;;
  let get_name buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 6)
  ;;
  let get_sources_count buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 70)
  ;;
  let get_sources_id buf ~count ~index =
    if index < 0 || index >= count then invalid_arg "index out of bounds";
    let pos = 72 + 0 * count + index * 2 in
    Probe_id.of_int_exn (Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 0))
  ;;
  let set_group_id buf field =
    let pos = 0 in
    Core.Iobuf.Poke.uint16_le buf ~pos:(pos  + 2) (Probe_id.to_int_exn field);
  ;;
  let set_id buf field =
    let pos = 0 in
    Core.Iobuf.Poke.uint16_le buf ~pos:(pos  + 4) (Probe_id.to_int_exn field);
  ;;
  let set_name buf field =
    let pos = 0 in
    Core.Iobuf.Poke.padded_fixed_string ~padding buf ~len:64 ~pos:(pos  + 6) field;
  ;;
  let set_sources_id buf ~count ~index field =
    if index < 0 || index >= count then invalid_arg "index out of bounds";
    let pos = 72 + 0 * count + index * 2 in
    Core.Iobuf.Poke.uint16_le buf ~pos:(pos  + 0) (Probe_id.to_int_exn field);
  ;;
  let to_sub_iobuf t = 
    Iobuf.sub t ~len:(get_message_length t + 0)
  ;;
  let to_unpacked buf =
    assert(buffer_length ~sources_count:0 <= Iobuf.length buf && (let pos = 0 in buffer_length ~sources_count:(Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 70)) <= Iobuf.length buf));
    {
      message_length = get_message_length buf;
      message_type = get_message_type buf;
      group_id = get_group_id buf;
      id = get_id buf;
      name = get_name buf;
      sources_id = Array.init (get_sources_count buf) ~f:(fun i -> get_sources_id buf ~count:(get_sources_count buf) ~index:i);
    }
  let of_unpacked iobuf u =
    let res = write iobuf
      ~group_id:u.group_id
      ~id:u.id
      ~name:u.name
      ~sources_count:(Array.length u.sources_id)
    in
    Array.iteri (u.sources_id) ~f:(fun i elt ->
      set_sources_id iobuf ~count:(Array.length u.sources_id) ~index:i elt
    );
    res
  let sexp_of_t _ t = sexp_of_t_unpacked (to_unpacked t)

  let t_of_sexp _ sexp =
    let unpacked = t_unpacked_of_sexp sexp in
    let t = Iobuf.create ~len:(message_length + 0 + 2 * Array.length unpacked.sources_id) in
    ignore (of_unpacked t unpacked : int);
    Iobuf.of_string (Iobuf.to_string t)
  ;;
  
end

module End_of_header = struct
  

  type t_unpacked = {
    message_length : int;
    message_type : char;
  } with sexp
  type (-'rw) t = ('rw, Iobuf.no_seek) Iobuf.t constraint 'rw = [> read ]

  let message_length = 2 - 0
  let message_type = 'Z'

  let buffer_length  = message_length + 0
  let write  buf =
    let pos = 0 in
    assert(Iobuf.length buf >= message_length + 0);
    Core.Iobuf.Unsafe.Poke.char buf ~pos:(pos  + 1) (message_type);
    let total_bytes_packed = 2 in
    Core.Iobuf.Unsafe.Poke.uint8 buf ~pos:(pos  + 0) (total_bytes_packed - 0);
    total_bytes_packed
  ;;

  let create  =
    let iobuf = Iobuf.create ~len:(message_length + 0) in
    let size = write  iobuf in
    assert (Iobuf.length iobuf = size);
    iobuf
  let get_message_length buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos  + 0)
  ;;
  let get_message_type buf =
    let pos = 0 in
    (Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos  + 1))
  ;;
  let to_sub_iobuf t = 
    Iobuf.sub t ~len:(get_message_length t + 0)
  ;;
  let to_unpacked buf =
    assert(buffer_length <= Iobuf.length buf);
    {
      message_length = get_message_length buf;
      message_type = get_message_type buf;
    }
  let of_unpacked iobuf _ =
    let res = write iobuf
    in
    res
  let sexp_of_t _ t = sexp_of_t_unpacked (to_unpacked t)

  let t_of_sexp _ sexp =
    let unpacked = t_unpacked_of_sexp sexp in
    let t = Iobuf.create ~len:(message_length + 0) in
    ignore (of_unpacked t unpacked : int);
    Iobuf.of_string (Iobuf.to_string t)
  ;;
  
end

module Epoch = struct
  

  type t_unpacked = {
    message_length : int;
    message_type : char;
    epoch : Profiler_epoch.t;
  } with sexp
  type (-'rw) t = ('rw, Iobuf.no_seek) Iobuf.t constraint 'rw = [> read ]

  let message_length = 10 - 0
  let message_type = 'E'

  let buffer_length  = message_length + 0
  let write ~epoch buf =
    let pos = 0 in
    assert(Iobuf.length buf >= message_length + 0);
    Core.Iobuf.Unsafe.Poke.char buf ~pos:(pos  + 1) (message_type);
    Core.Iobuf.Unsafe.Poke.int64_le buf ~pos:(pos  + 2) (Profiler_epoch.to_int epoch);
    let total_bytes_packed = 10 in
    Core.Iobuf.Unsafe.Poke.uint8 buf ~pos:(pos  + 0) (total_bytes_packed - 0);
    total_bytes_packed
  ;;

  let create ~epoch =
    let iobuf = Iobuf.create ~len:(message_length + 0) in
    let size = write ~epoch iobuf in
    assert (Iobuf.length iobuf = size);
    iobuf
  let get_message_length buf =
    let pos = 0 in
    Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos  + 0)
  ;;
  let get_message_type buf =
    let pos = 0 in
    (Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos  + 1))
  ;;
  let get_epoch buf =
    let pos = 0 in
    Profiler_epoch.of_int (Core.Iobuf.Unsafe.Peek.int64_le buf ~pos:(pos  + 2))
  ;;
  let set_epoch buf field =
    let pos = 0 in
    Core.Iobuf.Poke.int64_le buf ~pos:(pos  + 2) (Profiler_epoch.to_int field);
  ;;
  let to_sub_iobuf t = 
    Iobuf.sub t ~len:(get_message_length t + 0)
  ;;
  let to_unpacked buf =
    assert(buffer_length <= Iobuf.length buf);
    {
      message_length = get_message_length buf;
      message_type = get_message_type buf;
      epoch = get_epoch buf;
    }
  let of_unpacked iobuf u =
    let res = write iobuf
      ~epoch:u.epoch
    in
    res
  let sexp_of_t _ t = sexp_of_t_unpacked (to_unpacked t)

  let t_of_sexp _ sexp =
    let unpacked = t_unpacked_of_sexp sexp in
    let t = Iobuf.create ~len:(message_length + 0) in
    ignore (of_unpacked t unpacked : int);
    Iobuf.of_string (Iobuf.to_string t)
  ;;
  
end

type t_unpacked =
  | New_single_unpacked of New_single.t_unpacked
  | New_group_unpacked of New_group.t_unpacked
  | New_group_point_unpacked of New_group_point.t_unpacked
  | End_of_header_unpacked of End_of_header.t_unpacked
  | Epoch_unpacked of Epoch.t_unpacked
with sexp

module Message_type_and_errors = struct
  type _ t =
    | New_single : [ `New_single ] t
    | New_group : [ `New_group ] t
    | New_group_point : [ `New_group_point ] t
    | End_of_header : [ `End_of_header ] t
    | Epoch : [ `Epoch ] t
    | Need_more_data : [ `Need_more_data ] t
    | Invalid_message_type_or_subtype : [ `Invalid_message_type_or_subtype ] t
  let sexp_of_t : type a. _ -> a t -> Sexp.t = fun _ -> function
    | New_single -> Sexp.Atom "new_single"
    | New_group -> Sexp.Atom "new_group"
    | New_group_point -> Sexp.Atom "new_group_point"
    | End_of_header -> Sexp.Atom "end_of_header"
    | Epoch -> Sexp.Atom "epoch"
    | Need_more_data -> Sexp.Atom "need_more_data"
    | Invalid_message_type_or_subtype -> Sexp.Atom "invalid_message_type_or_subtype"
  
  type packed = T : _ t -> packed
  let sexp_of_packed (T t) = <:sexp_of< (string * _ t) >> ("t", t) 
end

let get_message_type buf =
  let len = Iobuf.length buf in
  let pos = 0 in
  if len < 2 then
    Message_type_and_errors.(T Need_more_data)
  else
    let message_length = 0 + Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos+0) in
    if len < message_length then Message_type_and_errors.(T Need_more_data)
    else begin
      match Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos + 1) with
      | 'E' ->
          if Epoch.buffer_length <= len
          then Message_type_and_errors.(T Epoch)
          else Message_type_and_errors.(T Need_more_data)
      | 'N' ->
          if New_single.buffer_length <= len
          then Message_type_and_errors.(T New_single)
          else Message_type_and_errors.(T Need_more_data)
      | 'O' ->
          if New_group_point.buffer_length ~sources_count:0 <= len && (let pos = 0 in New_group_point.buffer_length ~sources_count:(Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 70)) <= len)
          then Message_type_and_errors.(T New_group_point)
          else Message_type_and_errors.(T Need_more_data)
      | 'P' ->
          if New_group.buffer_length <= len
          then Message_type_and_errors.(T New_group)
          else Message_type_and_errors.(T Need_more_data)
      | 'Z' ->
          if End_of_header.buffer_length <= len
          then Message_type_and_errors.(T End_of_header)
          else Message_type_and_errors.(T Need_more_data)
      | other -> ignore other; Message_type_and_errors.(T Invalid_message_type_or_subtype)
    end
;;

let get_message buf _ = Iobuf.no_seek buf

let skip_message buf =
  let pos = 0 in
  if Iobuf.length buf < 1
  then failwith "Not enough data to read a message length to skip over!";
  Iobuf.advance buf (0 + Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos+0))
;;

let consuming_dispatch buf
  ~on_error
  ~on_epoch
  ~on_new_single
  ~on_new_group_point
  ~on_new_group
  ~on_end_of_header
    =
  let len = Iobuf.length buf in
  let pos = 0 in
  if len < 2 then
    on_error `Need_more_data
  else
    let message_length = 0 + Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos+0) in
    if len < message_length then on_error `Need_more_data
    else begin
      let no_seek_buf = (buf : (_, Iobuf.seek) Iobuf.t :> (_, Iobuf.no_seek) Iobuf.t) in
      match Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos + 1) with
      | 'E' ->
          if Epoch.buffer_length <= len then begin
            let result = on_epoch no_seek_buf in
            Iobuf.advance buf message_length;
            result
          end else on_error `Need_more_data
      | 'N' ->
          if New_single.buffer_length <= len then begin
            let result = on_new_single no_seek_buf in
            Iobuf.advance buf message_length;
            result
          end else on_error `Need_more_data
      | 'O' ->
          if New_group_point.buffer_length ~sources_count:0 <= len && (let pos = 0 in New_group_point.buffer_length ~sources_count:(Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 70)) <= len) then begin
            let result = on_new_group_point no_seek_buf in
            Iobuf.advance buf message_length;
            result
          end else on_error `Need_more_data
      | 'P' ->
          if New_group.buffer_length <= len then begin
            let result = on_new_group no_seek_buf in
            Iobuf.advance buf message_length;
            result
          end else on_error `Need_more_data
      | 'Z' ->
          if End_of_header.buffer_length <= len then begin
            let result = on_end_of_header no_seek_buf in
            Iobuf.advance buf message_length;
            result
          end else on_error `Need_more_data
      | other -> Iobuf.advance buf message_length; ignore other; on_error `Invalid_message_type_or_subtype
    end
;;

let consuming_dispatch_with_arg buf arg0
  ~on_error
  ~on_epoch
  ~on_new_single
  ~on_new_group_point
  ~on_new_group
  ~on_end_of_header
    =
  let len = Iobuf.length buf in
  let pos = 0 in
  if len < 2 then
    on_error arg0 `Need_more_data
  else
    let message_length = 0 + Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos+0) in
    if len < message_length then on_error arg0 `Need_more_data
    else begin
      let no_seek_buf = (buf : (_, Iobuf.seek) Iobuf.t :> (_, Iobuf.no_seek) Iobuf.t) in
      match Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos + 1) with
      | 'E' ->
          if Epoch.buffer_length <= len then begin
            let result = on_epoch no_seek_buf arg0 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 `Need_more_data
      | 'N' ->
          if New_single.buffer_length <= len then begin
            let result = on_new_single no_seek_buf arg0 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 `Need_more_data
      | 'O' ->
          if New_group_point.buffer_length ~sources_count:0 <= len && (let pos = 0 in New_group_point.buffer_length ~sources_count:(Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 70)) <= len) then begin
            let result = on_new_group_point no_seek_buf arg0 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 `Need_more_data
      | 'P' ->
          if New_group.buffer_length <= len then begin
            let result = on_new_group no_seek_buf arg0 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 `Need_more_data
      | 'Z' ->
          if End_of_header.buffer_length <= len then begin
            let result = on_end_of_header no_seek_buf arg0 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 `Need_more_data
      | other -> Iobuf.advance buf message_length; ignore other; on_error arg0 `Invalid_message_type_or_subtype
    end
;;

let consuming_dispatch_with_arg2 buf arg0 arg1
  ~on_error
  ~on_epoch
  ~on_new_single
  ~on_new_group_point
  ~on_new_group
  ~on_end_of_header
    =
  let len = Iobuf.length buf in
  let pos = 0 in
  if len < 2 then
    on_error arg0 arg1 `Need_more_data
  else
    let message_length = 0 + Core.Iobuf.Unsafe.Peek.uint8 buf ~pos:(pos+0) in
    if len < message_length then on_error arg0 arg1 `Need_more_data
    else begin
      let no_seek_buf = (buf : (_, Iobuf.seek) Iobuf.t :> (_, Iobuf.no_seek) Iobuf.t) in
      match Core.Iobuf.Unsafe.Peek.char buf ~pos:(pos + 1) with
      | 'E' ->
          if Epoch.buffer_length <= len then begin
            let result = on_epoch no_seek_buf arg0 arg1 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 arg1 `Need_more_data
      | 'N' ->
          if New_single.buffer_length <= len then begin
            let result = on_new_single no_seek_buf arg0 arg1 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 arg1 `Need_more_data
      | 'O' ->
          if New_group_point.buffer_length ~sources_count:0 <= len && (let pos = 0 in New_group_point.buffer_length ~sources_count:(Core.Iobuf.Unsafe.Peek.uint16_le buf ~pos:(pos  + 70)) <= len) then begin
            let result = on_new_group_point no_seek_buf arg0 arg1 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 arg1 `Need_more_data
      | 'P' ->
          if New_group.buffer_length <= len then begin
            let result = on_new_group no_seek_buf arg0 arg1 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 arg1 `Need_more_data
      | 'Z' ->
          if End_of_header.buffer_length <= len then begin
            let result = on_end_of_header no_seek_buf arg0 arg1 in
            Iobuf.advance buf message_length;
            result
          end else on_error arg0 arg1 `Need_more_data
      | other -> Iobuf.advance buf message_length; ignore other; on_error arg0 arg1 `Invalid_message_type_or_subtype
    end
;;

let of_unpacked iobuf u =
  match u with
  | New_single_unpacked msg -> (New_single.of_unpacked iobuf msg)
  | New_group_unpacked msg -> (New_group.of_unpacked iobuf msg)
  | New_group_point_unpacked msg -> (New_group_point.of_unpacked iobuf msg)
  | End_of_header_unpacked msg -> (End_of_header.of_unpacked iobuf msg)
  | Epoch_unpacked msg -> (Epoch.of_unpacked iobuf msg)

let to_unpacked buf =
  consuming_dispatch (Iobuf.sub buf) ~on_error:(function
    | `Need_more_data -> R.Need_more_data
    | `Invalid_message_type_or_subtype ->
        let exn = Failure "Invalid_message_type_or_subtype" in
        R.Junk (exn, Error exn))
    ~on_new_single:(fun buf -> R.Ok (New_single_unpacked (New_single.to_unpacked buf), Iobuf.length buf))
    ~on_new_group:(fun buf -> R.Ok (New_group_unpacked (New_group.to_unpacked buf), Iobuf.length buf))
    ~on_new_group_point:(fun buf -> R.Ok (New_group_point_unpacked (New_group_point.to_unpacked buf), Iobuf.length buf))
    ~on_end_of_header:(fun buf -> R.Ok (End_of_header_unpacked (End_of_header.to_unpacked buf), Iobuf.length buf))
    ~on_epoch:(fun buf -> R.Ok (Epoch_unpacked (Epoch.to_unpacked buf), Iobuf.length buf));;


type ('ty, -'rw) message = ('rw, Iobuf.no_seek) Iobuf.t constraint 'rw = [> read ]

let sexp_of_message _ _ message =
  match to_unpacked (Iobuf.sub message) with
  | R.Need_more_data
  | R.Junk _ as e -> failwiths "invalid message" e <:sexp_of< Nothing.t R.t >>
  | R.Ok (t, _) -> sexp_of_t_unpacked t
