(** This file is automatically generated by a target in the build system. Do not modify it
    by hand. *)

open! Core
module Time_ns = Time_ns_unix

val module_name : string

type (-'hierarchy, -'rw) t constraint 'rw = [> read ]
type ('hierarchy, 'rw) message = ('hierarchy, 'rw) t

val sexp_of_t : _ -> _ -> (_, _) t -> Sexp.t

type ('hierarchy, 'rw) t_no_exn = ('hierarchy, 'rw) t

val sexp_of_t_no_exn : _ -> _ -> (_, _) t_no_exn -> Sexp.t
val backing_iobuf : (_, 'rw) t -> ('rw, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t

val backing_iobuf_local
  :  local_ (_, 'rw) t
  -> local_ ('rw, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t

val globalize : local_ ('ty, 'rw) t -> ('ty, 'rw) t

module R : sig
  type 'message t =
    | Need_more_data
    | Ok of 'message * int
    | Junk of exn * (int, exn) Result.t
  [@@deriving sexp_of]
end

module Message_type_and_errors : sig
  type _ t =
    | New_single : [ `New_single ] t
    | New_group : [ `New_group ] t
    | New_group_point : [ `New_group_point ] t
    | End_of_header : [ `End_of_header ] t
    | Epoch : [ `Epoch ] t
    | Need_more_data : [ `Error ] t
    | Invalid_message_type_or_subtype : [ `Error ] t
    | Message_length_too_short : [ `Error ] t
  [@@deriving sexp_of]

  (** [all_of_packed] does not include the error cases. *)
  type packed = T : _ t -> packed [@@deriving sexp_of, enumerate] [@@unboxed]

  module Packed : sig
    (** The hash and compare functions throw on the error cases of
        [message_type_and_errors]. [all] does not include the error cases. *)
    type 'ty message_type_and_errors = 'ty t

    type t = packed = T : _ message_type_and_errors -> t
    [@@deriving sexp_of, enumerate] [@@unboxed]

    include Comparable.S with type t := t
    include Hashable.S with type t := t
  end

  val to_wire_exn : _ t -> char
  val of_wire : char -> packed

  (** [{to,of}]_index_exn provide dense packed integers starting from 0, suitable for
      indexing into an array. *)
  val to_index_exn : _ t -> int

  val of_index_exn : int -> packed
  val max_index : int
end

val get_message_type
  :  local_ ([> read ], _, Iobuf.global) Iobuf.Generic.t
  -> Message_type_and_errors.packed

(** [of_iobuf] must be fed a message type that comes from a call to [get_message_type] on
    the same window, otherwise it may cause segfaults or nonsensical reads. *)
val of_iobuf
  :  ('rw, _, Iobuf.global) Iobuf.Generic.t
  -> trusted:'ty Message_type_and_errors.t
  -> ('ty, 'rw) t

val of_iobuf_local
  :  local_ ('rw, _, Iobuf.global) Iobuf.Generic.t
  -> trusted:'ty Message_type_and_errors.t
  -> local_ ('ty, 'rw) t

val of_iobuf_exn
  :  ('rw, _, Iobuf.global) Iobuf.Generic.t
  -> 'ty Message_type_and_errors.t
  -> ('ty, 'rw) t

val of_iobuf_local_exn
  :  local_ ('rw, _, Iobuf.global) Iobuf.Generic.t
  -> 'ty Message_type_and_errors.t
  -> local_ ('ty, 'rw) t

module New_single : sig
  type phantom = [ `New_single ]
  type nonrec -'rw t = (phantom, 'rw) t constraint 'rw = [> read ] [@@deriving sexp]

  val message_type : char
  val buffer_length : int
  val globalize : local_ 'rw t -> 'rw t
  val of_iobuf_exn : ('rw, _, Iobuf.global) Iobuf.Generic.t -> 'rw t
  val of_iobuf_local_exn : local_ ('rw, _, Iobuf.global) Iobuf.Generic.t -> local_ 'rw t

  val write
    :  id:Probe_id.t
    -> spec:Probe_type.t
    -> name:string
    -> (read_write, _, Iobuf.global) Iobuf.Generic.t
    -> int

  val create
    :  id:Probe_id.t
    -> spec:Probe_type.t
    -> name:string
    -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val get_message_length : local_ _ t -> int
  val get_message_type : local_ _ t -> char
  val get_id : local_ _ t -> Probe_id.t
  val get_spec : local_ _ t -> Probe_type.t
  val name_max_len : int
  val get_name : local_ _ t -> string

  val get_name_zero_local_result
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> local_ 'a)
    -> local_ 'a

  val get_name_zero_local
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero
    :  _ t
    -> local_ ((read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero_padded_local_result
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> local_ 'a)
    -> local_ 'a

  val get_name_zero_padded_local
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero_padded
    :  _ t
    -> local_ ((read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val set_id : (read_write, _, Iobuf.global) Iobuf.Generic.t -> Probe_id.t -> unit
  val set_spec : (read_write, _, Iobuf.global) Iobuf.Generic.t -> Probe_type.t -> unit
  val set_name : (read_write, _, Iobuf.global) Iobuf.Generic.t -> string -> unit

  (** [set_name_zero buf f a] calls [f] on [buf], with the window adjusted to where [name]
      is. Even though [f] is given a seekable buffer, it must move nothing except the
      lower bound of the window past the data it wrote. *)
  val set_name_zero
    :  (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
    -> local_ ('a -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t -> unit)
    -> 'a
    -> unit

  val set_name_zero_local
    :  (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
    -> local_ (local_ 'a
               -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
               -> unit)
    -> local_ 'a
    -> unit

  val to_sub_iobuf : 'rw t -> ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val to_sub_iobuf_local
    :  local_ 'rw t
    -> local_ ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  module Unpacked : sig
    type t =
      { message_length : int
      ; message_type : char
      ; id : Probe_id.t
      ; spec : Probe_type.t
      ; name : string
      }
    [@@deriving sexp]

    val num_bytes : t -> int
    val write : t -> (read_write, _, Iobuf.global) Iobuf.Generic.t -> int
  end

  val to_unpacked : local_ 'rw t -> Unpacked.t
  val of_unpacked : Unpacked.t -> 'rw t
end

module New_group : sig
  type phantom = [ `New_group ]
  type nonrec -'rw t = (phantom, 'rw) t constraint 'rw = [> read ] [@@deriving sexp]

  val message_type : char
  val buffer_length : int
  val globalize : local_ 'rw t -> 'rw t
  val of_iobuf_exn : ('rw, _, Iobuf.global) Iobuf.Generic.t -> 'rw t
  val of_iobuf_local_exn : local_ ('rw, _, Iobuf.global) Iobuf.Generic.t -> local_ 'rw t

  val write
    :  id:Probe_id.t
    -> spec:Probe_type.t
    -> name:string
    -> (read_write, _, Iobuf.global) Iobuf.Generic.t
    -> int

  val create
    :  id:Probe_id.t
    -> spec:Probe_type.t
    -> name:string
    -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val get_message_length : local_ _ t -> int
  val get_message_type : local_ _ t -> char
  val get_id : local_ _ t -> Probe_id.t
  val get_spec : local_ _ t -> Probe_type.t
  val name_max_len : int
  val get_name : local_ _ t -> string

  val get_name_zero_local_result
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> local_ 'a)
    -> local_ 'a

  val get_name_zero_local
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero
    :  _ t
    -> local_ ((read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero_padded_local_result
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> local_ 'a)
    -> local_ 'a

  val get_name_zero_padded_local
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero_padded
    :  _ t
    -> local_ ((read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val set_id : (read_write, _, Iobuf.global) Iobuf.Generic.t -> Probe_id.t -> unit
  val set_spec : (read_write, _, Iobuf.global) Iobuf.Generic.t -> Probe_type.t -> unit
  val set_name : (read_write, _, Iobuf.global) Iobuf.Generic.t -> string -> unit

  (** [set_name_zero buf f a] calls [f] on [buf], with the window adjusted to where [name]
      is. Even though [f] is given a seekable buffer, it must move nothing except the
      lower bound of the window past the data it wrote. *)
  val set_name_zero
    :  (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
    -> local_ ('a -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t -> unit)
    -> 'a
    -> unit

  val set_name_zero_local
    :  (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
    -> local_ (local_ 'a
               -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
               -> unit)
    -> local_ 'a
    -> unit

  val to_sub_iobuf : 'rw t -> ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val to_sub_iobuf_local
    :  local_ 'rw t
    -> local_ ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  module Unpacked : sig
    type t =
      { message_length : int
      ; message_type : char
      ; id : Probe_id.t
      ; spec : Probe_type.t
      ; name : string
      }
    [@@deriving sexp]

    val num_bytes : t -> int
    val write : t -> (read_write, _, Iobuf.global) Iobuf.Generic.t -> int
  end

  val to_unpacked : local_ 'rw t -> Unpacked.t
  val of_unpacked : Unpacked.t -> 'rw t
end

module New_group_point : sig
  type phantom = [ `New_group_point ]
  type nonrec -'rw t = (phantom, 'rw) t constraint 'rw = [> read ] [@@deriving sexp]

  val message_type : char
  val buffer_length : sources_count:int -> int
  val globalize : local_ 'rw t -> 'rw t
  val of_iobuf_exn : ('rw, _, Iobuf.global) Iobuf.Generic.t -> 'rw t
  val of_iobuf_local_exn : local_ ('rw, _, Iobuf.global) Iobuf.Generic.t -> local_ 'rw t

  val write
    :  group_id:Probe_id.t
    -> id:Probe_id.t
    -> name:string
    -> sources_count:int
    -> (read_write, _, Iobuf.global) Iobuf.Generic.t
    -> int

  val create
    :  group_id:Probe_id.t
    -> id:Probe_id.t
    -> name:string
    -> sources_count:int
    -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val get_message_length : local_ _ t -> int
  val get_message_type : local_ _ t -> char
  val get_group_id : local_ _ t -> Probe_id.t
  val get_id : local_ _ t -> Probe_id.t
  val name_max_len : int
  val get_name : local_ _ t -> string

  val get_name_zero_local_result
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> local_ 'a)
    -> local_ 'a

  val get_name_zero_local
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero
    :  _ t
    -> local_ ((read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero_padded_local_result
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> local_ 'a)
    -> local_ 'a

  val get_name_zero_padded_local
    :  local_ _ t
    -> local_ (local_ (read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_name_zero_padded
    :  _ t
    -> local_ ((read, Iobuf.no_seek, Iobuf.global) Iobuf.Generic.t
               -> safe_pos:int
               -> safe_len:int
               -> 'a)
    -> 'a

  val get_sources_count : local_ _ t -> int

  (** Beware: [count] is trusted. If it is wrong, this function could read the wrong data
      or segfault. *)
  val get_sources_source_id : local_ 'rw t -> count:int -> index:int -> Probe_id.t

  val set_group_id : (read_write, _, Iobuf.global) Iobuf.Generic.t -> Probe_id.t -> unit
  val set_id : (read_write, _, Iobuf.global) Iobuf.Generic.t -> Probe_id.t -> unit
  val set_name : (read_write, _, Iobuf.global) Iobuf.Generic.t -> string -> unit

  (** [set_name_zero buf f a] calls [f] on [buf], with the window adjusted to where [name]
      is. Even though [f] is given a seekable buffer, it must move nothing except the
      lower bound of the window past the data it wrote. *)
  val set_name_zero
    :  (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
    -> local_ ('a -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t -> unit)
    -> 'a
    -> unit

  val set_name_zero_local
    :  (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
    -> local_ (local_ 'a
               -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
               -> unit)
    -> local_ 'a
    -> unit

  (** Beware: [count] is trusted. If it is wrong, this function could read the wrong data. *)
  val set_sources_source_id
    :  (read_write, _, Iobuf.global) Iobuf.Generic.t
    -> count:int
    -> index:int
    -> Probe_id.t
    -> unit

  (** Beware: [count] is trusted. If it is wrong, this function could read the wrong data. *)
  val write_sources
    :  (read_write, _, Iobuf.global) Iobuf.Generic.t
    -> count:int
    -> index:int
    -> source_id:Probe_id.t
    -> unit

  val to_sub_iobuf : 'rw t -> ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val to_sub_iobuf_local
    :  local_ 'rw t
    -> local_ ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  module Unpacked : sig
    type t_sources = { source_id : Probe_id.t } [@@deriving sexp]

    type t =
      { message_length : int
      ; message_type : char
      ; group_id : Probe_id.t
      ; id : Probe_id.t
      ; name : string
      ; sources_grp : t_sources array
      }
    [@@deriving sexp]

    val num_bytes : t -> int
    val write : t -> (read_write, _, Iobuf.global) Iobuf.Generic.t -> int
  end

  val to_unpacked : local_ 'rw t -> Unpacked.t
  val of_unpacked : Unpacked.t -> 'rw t
end

module End_of_header : sig
  type phantom = [ `End_of_header ]
  type nonrec -'rw t = (phantom, 'rw) t constraint 'rw = [> read ] [@@deriving sexp]

  val message_type : char
  val buffer_length : int
  val globalize : local_ 'rw t -> 'rw t
  val of_iobuf_exn : ('rw, _, Iobuf.global) Iobuf.Generic.t -> 'rw t
  val of_iobuf_local_exn : local_ ('rw, _, Iobuf.global) Iobuf.Generic.t -> local_ 'rw t
  val write : (read_write, _, Iobuf.global) Iobuf.Generic.t -> int
  val create : unit -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t
  val get_message_length : local_ _ t -> int
  val get_message_type : local_ _ t -> char
  val to_sub_iobuf : 'rw t -> ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val to_sub_iobuf_local
    :  local_ 'rw t
    -> local_ ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  module Unpacked : sig
    type t =
      { message_length : int
      ; message_type : char
      }
    [@@deriving sexp]

    val num_bytes : t -> int
    val write : t -> (read_write, _, Iobuf.global) Iobuf.Generic.t -> int
  end

  val to_unpacked : local_ 'rw t -> Unpacked.t
  val of_unpacked : Unpacked.t -> 'rw t
end

module Epoch : sig
  type phantom = [ `Epoch ]
  type nonrec -'rw t = (phantom, 'rw) t constraint 'rw = [> read ] [@@deriving sexp]

  val message_type : char
  val buffer_length : int
  val globalize : local_ 'rw t -> 'rw t
  val of_iobuf_exn : ('rw, _, Iobuf.global) Iobuf.Generic.t -> 'rw t
  val of_iobuf_local_exn : local_ ('rw, _, Iobuf.global) Iobuf.Generic.t -> local_ 'rw t

  val write
    :  epoch:Profiler_epoch.t
    -> (read_write, _, Iobuf.global) Iobuf.Generic.t
    -> int

  val create
    :  epoch:Profiler_epoch.t
    -> (read_write, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val get_message_length : local_ _ t -> int
  val get_message_type : local_ _ t -> char
  val get_epoch : local_ _ t -> Profiler_epoch.t

  val set_epoch
    :  (read_write, _, Iobuf.global) Iobuf.Generic.t
    -> Profiler_epoch.t
    -> unit

  val to_sub_iobuf : 'rw t -> ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  val to_sub_iobuf_local
    :  local_ 'rw t
    -> local_ ('rw, Iobuf.seek, Iobuf.global) Iobuf.Generic.t

  module Unpacked : sig
    type t =
      { message_length : int
      ; message_type : char
      ; epoch : Profiler_epoch.t
      }
    [@@deriving sexp]

    val num_bytes : t -> int
    val write : t -> (read_write, _, Iobuf.global) Iobuf.Generic.t -> int
  end

  val to_unpacked : local_ 'rw t -> Unpacked.t
  val of_unpacked : Unpacked.t -> 'rw t
end

module Unpacked : sig
  type t =
    | New_single of New_single.Unpacked.t
    | New_group of New_group.Unpacked.t
    | New_group_point of New_group_point.Unpacked.t
    | End_of_header of End_of_header.Unpacked.t
    | Epoch of Epoch.Unpacked.t
  [@@deriving sexp]

  val num_bytes : t -> int
  val message_type : t -> char
  val write : t -> (read_write, _, Iobuf.global) Iobuf.Generic.t -> int
end

val num_bytes_needed_for_message_length : int

(** Assuming the iobuf starts at a message, returns its length or raise if the window
    doesn't contain [num_bytes_needed_for_message_length] bytes. *)
val num_bytes_in_message : local_ ([> read ], _, Iobuf.global) Iobuf.Generic.t -> int

(** Equivalent to [Iobuf.advance buf (num_bytes_in_message buf)] *)
val skip_message : local_ ([> read ], Iobuf.seek, Iobuf.global) Iobuf.Generic.t -> unit

val buffer_contains_full_message
  :  local_ ([> read ], _, Iobuf.global) Iobuf.Generic.t
  -> bool

val of_unpacked : Unpacked.t -> (_, _, Iobuf.global) Iobuf.Generic.t
val to_unpacked : local_ ([> read ], _, Iobuf.global) Iobuf.Generic.t -> Unpacked.t R.t
val to_unpacked_exn : local_ ([> read ], _, Iobuf.global) Iobuf.Generic.t -> Unpacked.t
